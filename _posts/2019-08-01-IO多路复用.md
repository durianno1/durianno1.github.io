---
layout: post
title: 'I/O多路复用'
subtitle: 'select,poll,epoll'
date: 2020-10-20
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  操作系统
---
### select ###

部分源码：

![select](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/selectcode.png?raw=true)

1. 第一部分

   - 创建socket客户端

   - 创建五个文件描述符，放入fds，并记录max(max比最大的文件描述符大1)

2. 第二部分

   - 循环开始，表示持续监听
   - FD_ZERO将上次返回的rset全部置0，因为上次返回的rset中仅监听到的文件描述符位是1，本次需要重新和fds确定需要监听哪些文件描述符
   - FD_SET根据fds将rset指定位置1
   - 调用select，select的其他参数表示还可以监听其他类型事件，rset表示读事件的bitmap表
   - 注意，select的第一个参数表示需要关注的rset位数，max比最大文件描述符大1，锁以rset从第max位开始就全部是0，不需要内核关注。

3. 第三部分

   - select收到结果，阻塞被唤醒
   - 在内核中，rset中监听到的文件描述符位置1，表示该位代表的事件已经发生
   - 轮询遍历rset，FD_ISSET检查是否有事件发生
   - 处理对应事件
   - 此时rset已经被内核改变，所以在第一部分每次循环开始都要根据fds初始化rset



##### 缺点 #####

1. bitmap默认大小1024，能监听的文件描述符有限
2. rset在内核被改变，每次循环开始要重新根据fds重新初始化
3. 用户态到内核态复制rset开销大
4. select调用唤醒后还要轮询rset



### poll ###

部分源码：



