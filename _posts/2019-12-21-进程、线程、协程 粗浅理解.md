---
layout: post
title: '进程、线程、协程'
subtitle: '理解不深，未必准确，暂时记录'
date: 2019-12-21
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  操作系统 golang
---
先上一张总览图
![进程线程协程](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/process.jpg?raw=true)
## 进程
我的理解是，进程是一个程序的执行过程或者说是“正在执行的程序”，程序是一段代码和数据的静态实体，将程序的代码放入内存中，这时就产生了一个等待CPU处理的进程。CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，一般一个计算机同时有很多程序共同执行，对于单核CPU来说，只能做到并发，CPU会根据时间片的安排来选择每个时间段执行哪个进程，**一般来说流程是读取A的上下文、执行A、保存A的上下文，读取B上下文、执行B、保存B的上下文。。。。**一个A进程就是读取A的上下文、执行A、保存A的上下文的这段过程。不同进程在时间片中交替执行也是并发实现的方式。进程拥有自己独立的堆和栈，不与其他进程共享,进程的**进程的局限是创建撤销切换的成本很高。**

## 线程
一个进程通常会有很多分支和程序段，而这些粒度更小的调度单位就是我们引入的线程概念，把进程内执行A的那一步分化成了执行a小段，执行b小段，执行c小段，**线程也需要上下文读取和保存，但是成本很低。**这些线程共享进程内的资源，可以进行交互。一个进程如果需要很多操作，当一个操作阻塞时会一直等待，浪费其他操作的时间，而引入线程就可以分别代表各个操作，再次细化时间片，再次达到并发境界。

## 协程
只谈go语言中的协程吧，线程的调度由操作系统来安排，虽然线程上下文切换对内核的消耗已经小了很多，但是有时候还是会浪费一些资源。因为协程的切换只在用户空间进行，而线程会有内核级别的消耗，**对于内核级别的消耗我的理解就是需要操作系统来进行调度，而协程切换由人为设计，省去了操作系统的工作，只保留了CPU寄存器中上下文的消耗，所以更快。**
## 总结
**进程是操作系统为我们分配资源的基本单位，线程是进程内执行功能的基本单位，协程是线程内人为操控线程如何执行的人为因素。**好比一个视频播放器是一个进程，当我们进行快进操作时，画面获取和声音获取是两个线程来完成，而协程是我们设计的在这种功能内如何效率实现这种功能的技巧，比如画面获取功能里面的各种函数的执行顺序和方式等等。
系统会为进程分配内存地址和数据、文件等等，而线程没有实际的资源，它依附在进程内，使用的都是这个进程的地址。但是当一个线程出错时会导致进程崩坏，所以多进程的程序更加健壮，但是进程间通信成本也更高。
进程概念更偏向于内存管理，线程更偏向于CPU。
一个很形象的例子：
1.线程在进程下行进（单纯的车厢无法运行）
2.一个进程可以包含多个线程（一辆火车可以有多个车厢）
3.不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
4.同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
5.进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
6.进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
7.进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8.进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
9.进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”


目前理解有限，先记下来这些吧。






