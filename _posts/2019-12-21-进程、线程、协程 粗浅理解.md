---
layout: post
title: '进程、线程、协程'
subtitle: '理解不深，未必准确，暂时记录'
date: 2019-12-21
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  操作系统 golang
---
先上一张总览图
![进程线程协程](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/process.jpg?raw=true)
## 进程
我的理解是，进程是一个程序的执行过程或者说是“正在执行的程序”，程序是一段代码和数据的静态实体，将程序的代码放入内存中，这时就产生了一个等待CPU处理的进程。CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，一般一个计算机同时有很多程序共同执行，对于单核CPU来说，只能做到并发，CPU会根据时间片的安排来选择每个时间段执行哪个进程，**一般来说流程是读取A的上下文、执行A、保存A的上下文，读取B上下文、执行B、保存B的上下文。。。。**一个A进程就是读取A的上下文、执行A、保存A的上下文的这段过程。不同进程在时间片中交替执行也是并发实现的方式。进程拥有自己独立的堆和栈，不与其他进程共享,进程的**进程的局限是创建撤销切换的成本很高。**进程的栈区是用户态的，存储变量什么的。

## 线程
一个进程通常会有很多分支和程序段，而这些粒度更小的调度单位就是我们引入的线程概念，把进程内执行A的那一步分化成了执行a小段，执行b小段，执行c小段，**线程也需要上下文读取和保存，但是成本很低。**这些线程共享进程内的资源，可以进行交互。一个进程如果需要很多操作，当一个操作阻塞时会一直等待，浪费其他操作的时间，而引入线程就可以分别代表各个操作，再次细化时间片，再次达到并发境界。
一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成,堆是多个线程公用进程的，其他的都是保存在进程内但是每个线程独立拥有访问权的。**线程栈在其所在进程的堆区**

## 协程
只谈go语言中的协程吧，线程的调度由操作系统来安排，虽然线程上下文切换对内核的消耗已经小了很多，但是有时候还是会浪费一些资源。因为协程的切换只在用户空间进行，而线程会有内核级别的消耗，**对于内核级别的消耗我的理解就是需要操作系统来进行调度，而协程切换由人为设计，省去了操作系统的工作，只保留了CPU寄存器中上下文的消耗，所以更快。**
## 总结
**进程是操作系统为我们分配资源的基本单位，线程是进程内执行功能的基本单位，协程是线程内人为操控线程如何执行的人为因素。**好比一个视频播放器是一个进程，当我们进行快进操作时，画面获取和声音获取是两个线程来完成，而协程是我们设计的在这种功能内如何效率实现这种功能的技巧，比如画面获取功能里面的各种函数的执行顺序和方式等等。
系统会为进程分配内存地址和数据、文件等等，而线程没有实际的资源，它依附在进程内，使用的都是这个进程的地址。但是当一个线程出错时会导致进程崩坏，所以多进程的程序更加健壮，但是进程间通信成本也更高。
进程概念更偏向于内存管理，线程更偏向于CPU。
一个很形象的例子：
1.线程在进程下行进（单纯的车厢无法运行）
2.一个进程可以包含多个线程（一辆火车可以有多个车厢）
3.不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
4.同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
5.进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
6.进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
7.进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8.进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
9.进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”


目前理解有限，先记下来这些吧。


## 协程切换为什么比线程消耗低
协程切换完全在用户空间，只需要保存上下文(寄存器也比线程少)即可，线程除了用户空间，还有内核空间进出，线程优先级之类

## 为什么引入协程概念
协程的出现是为了解决性能问题的，不是为了代码的优雅而创建的。有了协程，代码可以写的更优雅，这只是附带的效果。博主的因果搞错了。
为什么使用协程
1. 由于现代CPU发展的越来越快，每一个时间片能够处理的指令越来越多，很经常导致一个线程时间片还未用完，而进入了等待数据IO的时间。此时该线程必然要让出CPU，让另一个线程运行
2. 之后有人提出了协程的概念，让同一个线程在一个CPU时间片内可以处理多个任务，虽然协程的切换也耗费时间，但总体来说要比线程的切换要好很多。因此，使用协程可以比使用线程能够得到更好的处理效果（这个不是一定的，还得跟服务器的任务性质以及协程的调度算法有关系，但一般情况下使用协程会比使用线程有更好的性能）
使用协程还有很多其他的好处，比如更轻量、支持更多的协程数量等等


## 内核台线程 用户态线程 协程 一些新理解
真正放到cpu上执行的是内核态线程，那什么是用户态线程呢？我理解的java里thread、go中的goroutine都是用户态线程，用户态线程是放到内核态线程中再给cpu执行的，cpu的核数更像是一个茅坑，内核态线程是人，用户态线程是粑粑。java的thread是条状的，goroutine是一个个球。一旦内核态线程中的线程阻塞，将导致该内核态线程被挂起，造成内核调度消耗，而协程会人为调度防止阻塞掉整个内核态线程，防止出现频繁内核态线程调度消耗。






