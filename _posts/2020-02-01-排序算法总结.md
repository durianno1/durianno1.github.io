---
layout: post
title: '排序算法总结'
subtitle: '十大经典排序算法记忆要点'
date: 2020-02-01
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  算法
---
排序算法总结
![排序算法分类](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/allsort.png?raw=true)
![排序算法复杂度](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/sortfzd.png?raw=true)

## 相关概念
    1.稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。   
    2.不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
    3.时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
    4.是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

## 冒泡排序
从头，两两相邻的进行比较，好像冒泡一样，把大的数字冒到后面。所以每次冒泡的上限是上一次-1。
![冒泡法图解](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/mp.gif?raw=true)

## 选择排序
选择法，每次选择一个位置，第几个位置就是第几的数字，每次循环就是要确定这个位置的数字应该是哪个，起点是上次起点+1.
![选择法图解](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/select.gif?raw=true)

## 插入排序
从第二个元素开始往前插，把第一个元素当一个排序后的序列，找到位置插进去。然后再从第三个元素开始，把前两个元素当成一个排序后的序列(也确实是，之前搞过了),找到位置插进去。然后再从下一个元素开始，以此类推。
![插入法图解](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/insert.gif?raw=true)

## 希尔排序
为了减少复杂度，对插入排序做修改。设定一个跨度并迭代它，每次循环用这个跨度挑选要排序的元素。在同跨度内，对同跨度前面的元素做插入排序。
![希尔法图解](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/hill.gif?raw=true)

## 快速排序
随机选定一个元素作为pivot，找到这个pivot应该在数组中的位置，然后再对左右两边做快速排序
核心思想包括三步：
    快速排序：
    1.确定pivot
    2.对左边快速排序
    3.对右边快速排序
如何找到pivot的位置呢？假如选定第一个元素left值为pivot，那么先从最右往左(right--)找到第一个比pivot小的元素right，然后将nums[left]等于nums[right],然后再从左向右(left++)找到比pivot大的元素，然后将nums[right]等于nums[left],再从右找比pivot小的，然后将nums[left]等于nums[right]。继续左右交替找(左边找大的，右边找小的),直到left=right，这个位置就是pivot应该处于的位置，也正好将nums一分为二，再分别对左右做快速排序。
记录一下代码:
```go
func sortArray(nums []int) []int {
    quickSort(nums,0,len(nums)-1)
    return nums
}
func quickSort(nums []int,left int,right int){
    if left < right{
        mid := getMid(nums,left,right)
        quickSort(nums,left,mid-1)
        quickSort(nums,mid+1,right)
    }
}
func getMid(nums []int,left int,right int)int{
    pivot := nums[left]
    for left<right{
        for nums[right]>=pivot&&right>left{
            right--
        }
        nums[left] = nums[right]
        for nums[left]<=pivot&&right>left{
            left++
        }
        nums[right] = nums[left]
    }
    nums[left] = pivot
    return left
}
```
![快排图解](https://github.com/durianno1/durianno1.github.io/blob/master/assets/img/quick.png?raw=true)





