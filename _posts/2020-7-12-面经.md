---
layout: post
title: '进程、线程、协程'
subtitle: '理解不深，未必准确，暂时记录'
date: 2019-12-21
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  操作系统 golang
---
### 操作系统
1.进程间通信有哪些，各个优缺点?
#### 匿名管道
在内存中维护一块区域，只能在具有亲缘关系的进程间进行数据传输，是一个循环队列，一端写一端读，在内存中，速度较快
#### 命名管道
把路径名以FIFO文件形式保存在硬盘中，任何可以访问硬盘的进程都可以通过命名管道进行通信
#### 消息队列
由操作系统维护的一块数据结构（链表），有读写权限的进程可以根据规则，通过消息队列进行读写以达到通信行为，传递的不是字节流，而是结构化的数据
#### 共享内存
允许多个进程共享的一块存储区，不需要额外的拷贝操作，速度快，但是需要控制（同步互斥），可以搭配信号量
#### 信号量
无法传输数据，只是传输一个信号，通过up down操作一块数据来达到沟通的效果

2.进程调度
#### 先来先服务
顺序执行，有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长
#### 短作业优先
按估计运行时间分配，长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度
#### 最短剩余时间
抢占式，新的进程如果剩余时间短则会挂起当前，执行新的进程
#### 时间片轮转
把就绪进程排成一个队列，根据时间片轮转算法挨个执行，执行后加入对尾继续等待
#### 优先级调度
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

3.IO复用
实现了单个线程监控多个网络连接的问题
#### select
select维护三个fd_set数组，分别监控对应连接可读、可写、异常事件。应用进程调用select，select将三个数组提交给内核（一次拷贝），内核遍历后把对应事件的fd交给应用程序（一次拷贝）
#### poll
随着连接数越来越多，fd_set难以维护，poll改用链表来监视fd，没有数量限制
#### epoll
面向内核维护一个事件表（B+树结构）用来保存应用进程需要监控哪些fd和对应类型的事件,可以随时添加或删除fd和事件类型，给fd绑定回调函数，当监控的fd活跃时候加入活跃队列，调用epollwait方法返回活跃队列。因为本身事件表就在内核空间，所以就避免了向select、poll一样每次都要把自己需要监听的事件列表传输过去，然后又传回来，这也就避免了事件信息需要在用户空间和内核空间相互拷贝的问题。
然后epoll并不是像select一样去遍历事件列表，然后逐个轮询的监控fd的事件状态，而是事先就建立了fd与之对应的回调函数，当事件激活后主动回调callback函数，这也就避免了遍历事件列表的这个操作,所以epoll并不会像select和poll一样随着监控的fd变多而效率降低，这种事件机制也是epoll要比select和poll高效的主要原因。



### 计算机网络



### 微服务分布式相关
1. 负载均衡算法
#### 轮询
顺序分配给服务器，不关心各个服务器实际连接数与负载状况
#### 随机
通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多
#### 源地址哈希法
通过客户端ip来映射一台服务器，每次都是同一台
#### 加权轮询
根据服务器负载情况加以权重，并在顺序分配时考虑
#### 最小连接数
最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取

2.分布式锁
分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁独立于每一个服务之外，而不是在服务里面。相当于给集群加了一个管家，每台服务器的请求要通过管家来保证隔离性
#### redis分布式锁
使用setnx（key value）命令，所有服务器统一key，value无所谓，当key没被设置的时候返回1否则返回0，拿到1的服务器获得了锁，可以进行操作。操作结束后del掉这个key，如果del之前就宕机了，防止死锁可以给key设置一个过期时间，expired key time，





### mysql
1.innodb聚簇索引和MyIsam非聚簇索引实现
#### innodb
b+树，叶子节点保存索引对应的完整数据
#### myisam
b+树，叶子节点保存索引对应数据的主键值，然后根据主键值回表

2.覆盖索引
要查询的数据在索引中

3.哈希索引
只有当要查询的内容覆盖所有列的时候才有效

4.事务
保证ACID四种特性的一组命令序列

5.ACID
#### 原子性
要么都执行成功，要么回滚拉倒
#### 一致性
命令执行前后数据库必须都是一致性状态，比如执行之前AB的资金和是5000，执行后也是5000，我把一致性当成一种合法性
#### 隔离性
数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离
#### 持久行
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

6.四种隔离级别
#### Read Uncommitted
所有事务都可以看到其他未提交事务的执行结果，读取未提交的数据，也被称之为脏读
#### Read Committed
一个事务只能看见已经提交事务所做的改变，所以同一事务可能读取到不同结果，因为其他实例commit了，会导致不可重复读，读两次出现不同结果
#### Repeatable read
可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的，会导致幻读，读到其他实例加入的新行
#### Serializable
读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读



### redis
1.基本数据类型
#### string
一个key对应一个value，value类型string是二进制安全的，可以包含任何数据，包括图片、序列化对象，最大512m
#### hash
#### list
其实是一个双向链表

2.缓存雪崩
大量缓存同时失效，请求涌向数据库 可以搭配限流+降级来解决

3.缓存穿透
查询一个缓存和数据库都不存在的东西，穿透缓存直达数据库 可使用布隆过滤器，将所有可能存在的数据哈希到一个bitmap里，如果找不到就直接忽略掉
