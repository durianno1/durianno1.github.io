---
layout: post
title: '面经总结'
subtitle: '为了offer！'
date: 2019-12-21
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags:  面经
---
### 操作系统
1.进程间通信有哪些，各个优缺点?
#### 匿名管道
在内核中维护一块缓存，只能在具有亲缘关系的进程间进行数据传输，是一个循环队列，一端写一端读，在内存中，速度较快
    ps auxf | grep mysql
将ps auxf的输出作为grep mysql的输入，“|”这个符号就是管道，我们可以看出他是单向匿名的，当进程关闭时，匿名管道也自动关闭
#### 命名管道
把路径名以FIFO文件形式保存在硬盘中，任何可以访问硬盘的进程都可以通过命名管道进行通信
    mkfifo mp
    echo "hello" > mp
    cat < mp
mkfifo创建一个命名管道文件，echo将hello写入，cat读取，可以看出这个行为是阻塞的，可以确认数据已被读取，命名管道除非手动删除设备文件否则一直存在
#### 消息队列
由操作系统维护的一块数据结构（链表），有读写权限的进程可以根据规则，通过消息队列进行读写以达到通信行为，传递的不是字节流，而是结构化的数据，如果不主动释放消息队列或者关闭操作系统，消息队列就一直存在。消息队列不适合传输太大的数据，消息拷贝由内核态到用户态，存在额外开销
#### 共享内存
让虚拟内存映射同一块物理内存，不需要额外的拷贝操作，速度快，但是需要控制（同步互斥），可以搭配信号量
#### 信号量
无法传输数据，只是传输一个信号，通过up down操作一块数据来达到沟通的效果

2.进程调度
#### 先来先服务
顺序执行，有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长
#### 短作业优先
按估计运行时间分配，长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度
#### 最短剩余时间
抢占式，新的进程如果剩余时间短则会挂起当前，执行新的进程
#### 时间片轮转
把就绪进程排成一个队列，根据时间片轮转算法挨个执行，执行后加入对尾继续等待
#### 优先级调度
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

3.IO复用
实现了单个线程监控多个网络连接的问题
#### select
系统建立多个sock，并将监听进程A放入这些sock中，当数据来了，中断cpu，将每个sock里的A删除
select维护三个fd_set数组，分别监控对应连接可读、可写、异常事件。应用进程调用select，select将三个数组提交给内核（一次拷贝），内核遍历后把对应事件的fd交给应用程序（一次拷贝）
#### poll
随着连接数越来越多，fd_set难以维护，poll改用链表来监视fd，没有数量限制
#### epoll
面向内核维护一个事件表（B+树结构）用来保存应用进程需要监控哪些fd和对应类型的事件,可以随时添加或删除fd和事件类型，给fd绑定回调函数，当监控的fd活跃时候加入活跃队列，调用epollwait方法返回活跃队列。因为本身事件表就在内核空间，所以就避免了向select、poll一样每次都要把自己需要监听的事件列表传输过去，然后又传回来，这也就避免了事件信息需要在用户空间和内核空间相互拷贝的问题。
然后epoll并不是像select一样去遍历事件列表，然后逐个轮询的监控fd的事件状态，而是事先就建立了fd与之对应的回调函数，当事件激活后主动回调callback函数，这也就避免了遍历事件列表的这个操作,所以epoll并不会像select和poll一样随着监控的fd变多而效率降低，这种事件机制也是epoll要比select和poll高效的主要原因。
epoll不会让每个 socke t的等待队列都添加进程A引用，而是在等待队列，添加 eventPoll对象的引用。
当socket就绪时，中断程序会操作eventPoll，在eventPoll中的就绪列表(rdlist)，添加scoket引用。
这样的话，进程A只需要不断循环遍历rdlist，从而获取就绪的socket。
从代码来看每次执行到epoll_wait，其实都是去遍历 rdlist。
如果rdlist为空，那么就阻塞进程。
当有socket处于就绪状态，也是发中断信号，再调用对应的中断程序。
此时中断程序，会把socket加到rdlist，然后唤醒进程。进程再去遍历rdlist，获取到就绪socket。
总之： poll是翻译轮询的意思，我们可以看到poll和epoll都有轮询的过程。
不同点在于：
poll轮询的是所有的socket。
而epoll只轮询就绪的socket。
epoll 水平触发（LT）与 边缘触发（ET）的区别：
LT：只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作
ET：它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误

4.协程相关
#### 协程比线程快在哪
除了都有的cpu替换上下文，少了线程在内核中的一些操作（调度）


5.死锁
#### 产生条件
##### 互斥条件
临界资源是独占资源，进程应互斥且排他的使用这些资源。
##### 占有和等待条件
进程在请求资源得不到满足而等待时，不释放已占有资源。
##### 不剥夺条件
又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。
###### 循环等待条件
又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。

#### 防止
破坏产生条件

#### 预防
禁止一个线程获取多个锁，防止成环
或者锁设置时间

#### 解决
释放资源




### 计算机网络
#### 为什么要三次握手
1.确认双方都知道彼此都有收发能力，第二次握手让客户端知道了自己和服务端都有收发能力，第三次握手让服务端知道了自己和客户端都有手法能力。
2.第一次握手如果因为走弯路客户端迟迟没有收到回应，则客户端发起超时重传，等连接建立完毕数据也传输完毕关闭了连接后，走弯路的第一次握手申请才到服务端，这时服务端会想客户端发ack，如果两次握手就可以建立连接的话，那此时服务端会认为自己已经建立了连接。
#### time_wait 2mls
1.确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。A->B ACK 1MSL B的超时重传时间设置1MSL，若ACK丢失，则重传FIN 1MSL ，所以2MSL（重传等待或者说ACK寿命+FIN寿命）
2.等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文，防止影响新链接
#### https
c发送策略组，s选择并返回公钥和证书，c检查证书生成密钥用公钥加密发给s，s用私钥解密
#### time_wait堆积与close_wait堆积
time_wait出现在主动发起断开的一端，close_wait出现在被动断开连接的一端
如果端口忙，可以设置so_reuseaddr,time_wait状态可以重用端口





### 微服务分布式相关
1. 负载均衡算法
#### 轮询
顺序分配给服务器，不关心各个服务器实际连接数与负载状况
#### 随机
通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多
#### 源地址哈希法
通过客户端ip来映射一台服务器，每次都是同一台
#### 加权轮询
根据服务器负载情况加以权重，并在顺序分配时考虑
#### 最小连接数
最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取

2.分布式锁（单redis）
分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁独立于每一个服务之外，而不是在服务里面。相当于给集群加了一个管家，每台服务器的请求要通过管家来保证隔离性
#### redis分布式锁
使用setnx（key value）命令，所有服务器统一key，value无所谓，当key没被设置的时候返回1否则返回0，拿到1的服务器获得了锁，可以进行操作。操作结束后del掉这个key，如果del之前就宕机了，防止死锁可以给key设置一个过期时间，expired key time，考虑到如果在设置过期时间前宕机，可以直接使用set key value EX seconds NX EX表示过期时间，NX表示只有当锁不存在时才设置EX。（只适用于单机模式，主从集群等情况下不安全）
四大特性
##### 互斥性
在任意时刻，只有一个客户端能持有锁 其他尝试获取锁的客户端都将失败而返回或阻塞等待
##### 
健壮性一个客户端持有锁的期间崩溃而没有主动释放锁，也需要保证后续其他客户端能够加锁成功，就像C++的智能指针来避免内存泄漏一样
##### 唯一性
加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给释放了，自己持有的锁也不能被其他客户端释放
##### 高可用
不必依赖于全部Redis节点正常工作，只要大部分的Redis节点正常运行，客户端就可以进行加锁和解锁操作

3.redlock（多redis）
##### 获取当前Unix时间，以毫秒为单位
##### 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等
##### 客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功
##### 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要
##### 如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题







### mysql
1.innodb聚簇索引和MyIsam非聚簇索引实现
#### innodb
b+树，叶子节点保存索引对应的完整数据
#### myisam
b+树，叶子节点保存索引对应数据的主键值，然后根据主键值回表

2.覆盖索引
要查询的数据在索引中

3.哈希索引
只有当要查询的内容覆盖所有列的时候才有效

4.事务
保证ACID四种特性的一组命令序列

5.ACID
#### 原子性
要么都执行成功，要么回滚拉倒
#### 一致性
命令执行前后数据库必须都是一致性状态，比如执行之前AB的资金和是5000，执行后也是5000，我把一致性当成一种合法性
#### 隔离性
数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离
#### 持久行
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

6.四种隔离级别
#### Read Uncommitted
所有事务都可以看到其他未提交事务的执行结果，读取未提交的数据，也被称之为脏读
脏读：脏读即为事务1第二次读取时，读到了事务2未提交的数据。若事务2回滚，则事务1第二次读取时，读到了脏数据
#### Read Committed
一个事务只能看见已经提交事务所做的改变，所以同一事务可能读取到不同结果，因为其他实例commit了，会导致不可重复读，读两次出现不同结果
不可重复度：不可重复读与脏读逻辑类似。主要在于事务2在事务1第二次读取时，提交了数据。导致事务1前后两次读取的数据不一致
#### Repeatable read
可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的，会导致幻读，某数据被其他事务插入，但是我查不到，我插也插不进去
幻读：第一次读读不到，但是update却成功了，因为其他事务insert了（间隙锁锁住查询范围内的每一行存不存在的都锁）

#### Serializable
读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读

7.B+树为什么比二叉树更适合做索引
深度低————查询效率高，相邻数据页可用数据少————导致io增多






### redis
1.基本数据类型
#### string
一个key对应一个value，value类型string是二进制安全的，可以包含任何数据，包括图片、序列化对象，最大512m
#### hash
#### list
其实是一个双向链表

2.缓存雪崩
大量缓存同时失效，请求涌向数据库 可以搭配限流+降级来解决

3.缓存穿透
查询一个缓存和数据库都不存在的东西，穿透缓存直达数据库 可使用布隆过滤器，将所有可能存在的数据哈希到一个bitmap里，如果找不到就直接忽略掉

4.缓存击穿
某热点数据过期，可以设置降级，永不过期，加分布式锁

4.持久化
#### RDB快照
将瞬时数据库状态存入二进制文件中,有点是可以放入子进程，不影响redis服务器，二进制文件小，缺点是需要额外系统空间，定期保存中若宕机会丢失数据
#### AOF日志
将语句调用过程(增量)写入文本，优点是always，everysecond，no三种形式可以灵活协调性能和安全性，缺点是文件大，载入慢


### linux
#### 查看io高的进程
iostat -x 1 10

